# Цель

Данный репозиторий предоставляет пример организации параллельных вычислений на основе процессов в `Python`. Конкретная выполняемая задача определяется конфигурационным файлом, передающимся как параметр при запуске нужного скрипта. Так как параллелизм на основе процессов требует скрипт с явно выделенной функцией `__main__`, то при самом наивном подходе возникают одинаковые скрипты, в которых сама схема обработки данных и вычислений практически идентичная, но отличаются только вызываемая функция и код, передающий ей данные. Предложенный здесь вариант решает проблему дублирования скриптов для запуска вычислений. Для этого фиксируется структура процесса вычислений, которая не зависит от конкретной задачи, а гибкость возникает за счёт написания пользовательских функций и конфигурационных файлов. 

# Идея 

Скрипт `grid_compute.py` осуществляет параллельное выполнение задачи на одномерной или двумерной сетке параметров. Выбор конкретных параметров, их диапазонов значений и разбиение отрезка, а также конкретная задача целиком определяются передаваемым в скрипт конфигурационным файлом и подключаемым модулем `workers.py`. Это является важной особенностью скрипта `grid_compute.py`: ему неважно, какую задачу выполнять, главное чтобы правильно взаимодействовали между собой функции в `workers.py` и передаваемый конфигурационный файл. 

# Схема работы `grid_compute.py` 

Работа скрипта `grid_compute.py` разделяется на три ключевых этапа:
1. **Выполнение `init`-функции.**
   
   Этот этап выполняется до параллельных вычислений. На нём может создаваться директория для сохранения файлов, создаваемых скриптом, или, например, собираться информация, связанная с воспроизводимостью данных. Функция `fullInit` в модуле `workers_utils.py` реализует пример описанного выше функционала. Она всегда по умолчанию собирает информацию о текущем статусе репозитория, пути к вызванному скрипту и использованному конфигурационному файлу, текущие ветку и коммит, версии всех установленных пакетов `Python`, а также содержимое конфигурационного файла. На данный момент видится, что эта функция максимально покрывает нужды по созданию структуры директорий и сохранению необходимой информации для воспроизведимости данных. 
2. **Параллельное исполнение `worker`-функции.**
   
    Этот шаг является главным с вычислительной точки зрения. Процессы для каждого переданного им узла сетки выполняют тяжёлую вычислительную задачу: например, расчёт траектории системы дифференциальных уравнений, вычисление каких-то связанных с ней характеристик и т.п. Также это может быть построение каких-либо изображений, относящихся к данным значениям параметров. 
3. **Выполнение `post`-функции.**
   На этом шаге происходит окончательная обработка результатов вычислений `worker`-функций. Например, это может быть построение графика или карты на основе полученных данных и сохранение их в файл.

# "Протокол" `workers.py`
Под "протоколом" подразумеваются следующие требования к файлу `workers.py` и входящим в него функциям:
1. В нём  на уровне модуля должна бытьопределена переменная `registry`, представляющая собой `dictionary` с ключами `init`, `worker`, `post`. В качестве значений по этим ключам хранятся другие `dictionary`, сопоставляющие задачу и используемую для неё `init`, `worker` или `post` функцию. Например:

```Python
registry = {
        "worker": {},
        "init": {},
        "post": {}
    }
registry['init']['approachTime'] = fullInit
registry['init']['poincareMap'] = fullInit
```

2. `init`-функция должна иметь сигнатуру вида `fullInit(config, timeStamp)`, где `config` есть `dictionary`, хранящий данные из конфигурационного файла, а `timeStamp` — время старта скрипта. Эта функция может возвращать некоторую информацию для дальнейшего использования в `worker`- и `post`-функциях. Так, например, `fullInit` возвращает `dictionary`, содержащий по ключу `targetDir` путь к директории, в которой будут сохраняться файлы. 
3. `worker`-функция должна иметь сигнатуру вида
`workerPoincareMap(gridNode: tuple[GridPoint], config, timeStamp, initResult)`.
Здесь `gridNode` — это передаваемая информация об узле сетки, а `initResult` — информация, переданнаяп после выполнения `init`-функции. Аргументы `config` и `timeStamp` имеют тот же смысл, что и для `init`-функции.
4. `post`-функция должна иметь сигнатуру вида `postApproachTime(config, initResult, workerResult, grid: list[list[GridPoint]], startTime)`, где `workerResult` — это список возвращённых значений в результате работы каждого вызова `worker`-функции, `grid` — список одномерных сеток по каждому параметру. Остальные аргументы имеют тот же смысл, что и для предыдущих функций.

# "Протокол" модификации 

Для гибкого использования конфигурационных файлов требуется, чтобы некоторые объекты могли обновлять свои поля, принимая `dictionary`. Например, в рассмотренной здесь задаче у исследуемой системы ОДУ есть стандартные значения параметров, которые затем обновляются в каждой точке сетки параметров. Для этого класс, хранящий информацию о параметрах системы, имеет дополнительный метод `setParams`:

```Python
class StuartLandau:
    """ Stuart-Landau system """

    def __init__(self, r, omega, s):
        self.r = r
        assert omega > 0., "omega must be greater than zero!"
        self.omega = omega
        assert s > 0, "alpha must be greater than zero!"
        self.s = s

    def setParams(self, paramDict):
        for key in paramDict:
            if hasattr(self, key):
                setattr(self, key, paramDict[key])
            else:
                raise KeyError(f"System has no parameter '{key}'")

    def getSystem(self, t, X):
        x, y = X
        om, s, r = self.omega, self.s, self.r
        dx = +om * y + s * x * (r * r - x * x - y * y)
        dy = -om * x + s * y * (r * r - x * x - y * y)
        return [dx, dy]
```

Для задания значений параметров по умолчанию в конфигурационных файлах используется ключ `defaultSystem`.

# Структура конфигурационного файла

Работа `grid_compute.py` жёстко завязана на наличие в конфигурационном файле некоторых ключей. В качестве используемого формата файла ожидается `YAML`, как поддерживающий комментарии и наиболее удобный с точки зрения читаемости. Единственным пока обнаруженным минусом этого формата является требование к написанию вещественных чисел в экспоненциальной форме записи: `1e-6` воспринимается при обработке как строка, тогда как для обработки как вещественного числа требуется записать `1.0e-6`.

## Ключ `grid`
Приведём пример из конфигурационного файла в репозитории:
```YAML
grid:
  second:
    max: 5
    steps: 3
    name: omega
    min: 3
    caption: \omega
  first:
    max: 1.5
    steps: 3
    name: s
    min: 0.5
    caption: s
```

По ключу `grid` находится словарь, который должен содержать либо только ключ `first`, либо оба ключа `first` и `second`. В ключах `min` и `max` записаны соответственно минимальное и максимальное значение параметра, а `steps` указывает на количество узлов в разбиении отрезка, включая концевые точки. В ключе `name` используется такое же строковое имя, как и в классе, объекты которого дальше будут модифицироваться параметрами из узла сетки. В ключе `caption` указана `LaTeX`-формула для отображения этого параметра на изображениях, но он не является принципиально обязателем для работы `grid_compute.py`.

## Ключ `task`

По этому ключу записана строка, определяющая задачу для исполнения скриптом. Этот ключ обязательный, он напрямую используется в `grid_compute.py` при определении соответствующих `init`, `worker` и `post` функций. 

## Ключ `[taskName]`

Здесь мы придерживаемся соглашения, что все аргументы, необходимые для выполнения задачи `[taskName]` (строка, которая находится по ключу `task` в конфигурационном файле), хранятся по соответствующему ключу. Этот ключ не является обязательным для работы `grid_compute.py`.